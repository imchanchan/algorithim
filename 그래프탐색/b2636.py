"""
13 12
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 0 0 0
0 1 1 1 0 0 0 1 1 0 0 0
0 1 1 1 1 1 1 0 0 0 0 0
0 1 1 1 1 1 0 1 1 0 0 0
0 1 1 1 1 0 0 1 1 0 0 0
0 0 1 1 0 0 0 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0


"""


def melt(graph):

    # 1. outside ===
    for n in range(N):
        for m in range(M):
            if graph[n][m] == 1:
                # graph[n][m-1] = 2
                break
            graph[n][m] = 2

        for m in range(M - 1, -1, -1):
            if graph[n][m] == 1:
                # graph[n][m+1] = 3
                break
            graph[n][m] = 3

    for m in range(M):
        for n in range(N):
            if graph[n][m] == 1:
                # graph[n-1][m] = 4
                break
            graph[n][m] = 4

        for n in range(N - 1, -1, -1):
            if graph[n][m] == 1:
                # graph[n+1][m] = 5
                break
            graph[n][m] = 5

    # # [확인]
    # print("="*100)
    # for o in graph:
    #     print(o)
    # print("="*100)

    # 2. outside 옆에 1 탐색
    dx = [0, 0, -1, 1]
    dy = [-1, 1, 0, 0]

    for n in range(N):
        for m in range(M):
            if graph[n][m] == 1:
                for k in range(4):
                    nn = n + dx[k]
                    nm = m + dy[k]

                    # if graph[nn][nm] == "*":
                    #     continue

                    if (
                        int(graph[nn][nm]) > 1
                        and nn >= 0
                        and nn < N
                        and nm >= 0
                        and nm < M
                    ):

                        graph[n][m] = 0
                        break

    # for g in graph:
    #     print(*g)

    return graph


# --------
# input
N, M = map(int, input().split(" "))

g = []
outside = []
for i in range(N):
    g.append(list(map(int, input().split(" "))))
    outside.append([0 for _ in range(M)])
print(g)
# print(outside)


# --- 시간 별 실행행

import copy

cnt = 0

while 1:

    # 1. 그래프에서 0이 없는경우 while 탈출 !!!
    ## graph는 모두 다 녹은 경우 / pre_graph는 다 녹기 전 경우
    cnt_1 = 0
    for i in g:
        if 1 not in i:
            cnt_1 += 1
    if cnt_1 == N:
        break

    cnt += 1

    print(f" =={cnt}==")

    # 2. graph이전 단계 복사하기 !!
    pre_g = copy.deepcopy(g)

    # 3. 치즈 녹이기 !!
    g = melt(g)
    for i in g:
        print(i)

    # 4. 확인! => False여야한다.
    # pre_g : 이전
    # g     : 이후
    print("*", pre_g == g)

# == 최종 ==
print("== 최종 ==")
for i in pre_g:
    print(i)

print("^" * 100)
for i in g:
    print(i)


print(cnt)
cnt_1 = 0
for i in pre_g:
    if 1 in i:
        cnt_1 += 1
print(cnt_1)

"""
[문제1]
- 1관점으로 생각해서, 밖에 있는 1일떄를 0과 만나면으로 할까했지만, 안쪽에 있는 0과 밖에 있는 0을 구분하기 어렵다. 

[해결1]
- outside 그래프를 도입해서, 밖에 있는 0만 표시를 하자. 
- graph값이 1일때와, outside값이 인접했을때 graph 1값을 0으로 만들자. 

[문제2]
- outside를 어떻게 만들까? 

[해결2]
- 한행씩 훑으면서!! 
- 좌>>우 방향으로, graph값이 0일때 쭉 1로 표시하다가, graph값이 1일때 break하자. 
- 우>>좌좌 방향으로, graph값이 0일때 쭉 1로 표시하다가, graph값이 1일때 break하자. 

[문제3]
- 예시) graph가 '0001110011100' 일때, 
- 좌>>우 방향 : outside = '111 00000000 00'
- 우>>좌 방향 : outside = '111 00000000 11'
이렇게 된다. outside정답은  111 000 11 000 11 이렇게 되어야한다. 

[해결3]
- 즉, 위에서 아래 방향으로, 아래에서 위 방향으로 훑어야한다.
- 사고를 빛처럼 해보자ㅋㅋ. 좌, 우, 위, 아래에서 비출때 각각 햇빛 받는 영역을 outside에서 1,2,3,4로 표시하자.

[성공]

>> outside
[4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4]
[4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4]
[4, 3, 3, 3, 3, 3, 3, 0, 0, 4, 4, 4]
[4, 0, 0, 0, 3, 3, 3, 0, 0, 4, 4, 4]
[4, 0, 0, 0, 0, 0, 0, 2, 2, 4, 4, 4]
[4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4]
[4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4]
[4, 4, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4]
[4, 4, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4]
[4, 4, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4]
[4, 4, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4]
[4, 4, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4]
[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]

>> 한시간뒤 녹은 치즈 graph결과과
['0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
['0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
['0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
['0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
['0', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0']
['0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0']
['0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0', '0']
['0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0', '0']
['0', '0', '0', '1', '1', '1', '1', '1', '0', '0', '0', '0']
['0', '0', '0', '1', '1', '1', '1', '1', '0', '0', '0', '0']
['0', '0', '0', '1', '1', '1', '1', '1', '0', '0', '0', '0']
['0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
['0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']


[문제4]
- 한번 돌때, 4방으로 outside만드는 과정 또 outside랑 인접했는지 삭제하는 과정이 시간도 많이 들고, 
- 메모리관점에서 볼때, outside와 graph를 보면 개념적으로 여집합 관계인데, 굳이 outside를 만들어야하나?  그냥 하나의 graph에다 표기해보자. 

[해결4]
- 우>>좌[2], 좌>>우[3], 위>>아래[4], 아래>>위[5] 방향으로 숫자를 다르게 설정한다음,
- 2이상이면, (터트리자!) 0으로 만들어버리자.
- 즉, outside를 만들지말고 개념만 가지고 만들자. 

>> 결과
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0]
[0, 4, 4, 4, 0, 0, 2, 1, 1, 3, 0, 0]
[2, 1, 1, 1, 4, 4, 4, 1, 1, 3, 0, 0]
[2, 1, 1, 1, 1, 1, 1, 3, 0, 0, 0, 0] >> [2, 1, 1, 1, 1, 1, 1, 3, "3", 0, 0, 0] 이 되어야한다. 
[2, 1, 1, 1, 1, 1, 0, 1, 1, 3, 0, 0]
[2, 1, 1, 1, 1, 0, 0, 1, 1, 3, 0, 0]
[0, 5, 1, 1, 0, 0, 0, 1, 1, 3, 0, 0]
[0, 2, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0]
[0, 2, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0]
[0, 2, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0]
[0, 2, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0]
[0, 0, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0]

[문제5]
- 위 행에서 발생한 문제! 

[해결5]
- 그냥 끝부분만 바꾸지말고, graph에서 개념적으로 outside에 해당하는 모든 부분을 싹다 바꾸자.

>> 성공!! 
>> outside 부분을 graph에 표현하기. 
[5, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5]
[5, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5]
[5, 4, 4, 4, 4, 4, 4, 1, 1, 5, 5, 5]
[5, 1, 1, 1, 4, 4, 4, 1, 1, 5, 5, 5]
[5, 1, 1, 1, 1, 1, 1, 3, 3, 5, 5, 5]
[5, 1, 1, 1, 1, 1, 0, 1, 1, 5, 5, 5]
[5, 1, 1, 1, 1, 0, 0, 1, 1, 5, 5, 5]
[5, 5, 1, 1, 0, 0, 0, 1, 1, 5, 5, 5]
[5, 5, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5]
[5, 5, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5]
[5, 5, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5]
[5, 5, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5]
[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
=========================================

>> 최종적으로 지워하는 (치즈에서 녹아 없어진) 1 -> 0 이 되었다. 
[5, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5]
[5, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5]
[5, 4, 4, 4, 4, 4, 4, 0, 0, 5, 5, 5]
[5, 0, 0, 0, 4, 4, 4, 0, 0, 5, 5, 5]
[5, 0, 1, 1, 0, 0, 0, 3, 3, 5, 5, 5]
[5, 0, 1, 1, 1, 1, 0, 0, 0, 5, 5, 5]
[5, 0, 1, 1, 1, 0, 0, 1, 0, 5, 5, 5]
[5, 5, 0, 1, 0, 0, 0, 1, 0, 5, 5, 5]
[5, 5, 0, 1, 1, 1, 1, 1, 0, 5, 5, 5]
[5, 5, 0, 1, 1, 1, 1, 1, 0, 5, 5, 5]
[5, 5, 0, 1, 1, 1, 1, 1, 0, 5, 5, 5]
[5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5]
[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]

[문제6]
- 다 살아질때 까지 while 문 돌리기
- 치즈가 다 살아지기 직전 (1시간전) 인지하기

[문제6-1]
- pre_g == g True가 나온다..

[해결6-1]
- 얕은 복사이기에, g의 진정한 복사본을 만들어야한다 !!! 
깊은 복사로 !! 

[문제6-2]
- 음.. 함수내부에서 ?? 

[해결6-2]
- 함수내부에서 graph를 deepcopy해서 써야해.

>> 성공이다!! 
== 최종 ==
[5, 5, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5]
[5, 5, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5]
[5, 5, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5]
[5, 5, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5]
[5, 5, 0, 0, 4, 4, 4, 4, 5, 5, 5, 5]
[5, 5, 0, 1, 0, 0, 4, 4, 5, 5, 5, 5]
[5, 5, 0, 1, 1, 0, 4, 0, 5, 5, 5, 5]
[5, 5, 5, 0, 0, 0, 4, 0, 5, 5, 5, 5]
[5, 5, 5, 0, 1, 1, 0, 0, 5, 5, 5, 5]
[5, 5, 5, 0, 1, 1, 1, 0, 5, 5, 5, 5]
[5, 5, 5, 0, 0, 0, 0, 0, 5, 5, 5, 5]
[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[5, 5, 5, 4, 4, 4, 4, 5, 5, 5, 5, 5]
[5, 5, 5, 4, 4, 4, 4, 5, 5, 5, 5, 5]
[5, 5, 5, 4, 4, 4, 4, 5, 5, 5, 5, 5]
[5, 5, 5, 4, 4, 4, 4, 5, 5, 5, 5, 5]
[5, 5, 5, 4, 4, 4, 4, 5, 5, 5, 5, 5]
[5, 5, 5, 0, 4, 4, 4, 5, 5, 5, 5, 5]
[5, 5, 5, 0, 0, 4, 4, 5, 5, 5, 5, 5]
[5, 5, 5, 5, 3, 4, 4, 5, 5, 5, 5, 5]
[5, 5, 5, 5, 0, 0, 4, 5, 5, 5, 5, 5]
[5, 5, 5, 5, 0, 0, 0, 5, 5, 5, 5, 5]
[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]

"""


'''
[문제7 싹 다 틀 렸 다 ..]

(햇빛 논법 틀림)
[5, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5]
[5, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5]
[5, 4, 4, 4, 4, 4, 4, 0, 0, 5, 5, 5]
[5, 0, 0, 0, 4, 4, 4, 0, 0, 5, 5, 5]
[5, 0, 1, 1, 0, 0, 0, 3, 3, 5, 5, 5]
[5, 0, 1, 1, 1, 1, 0, 0, 0, 5, 5, 5]
[5, 0, 1, 1, 1, "0", "0", 1, 0, 5, 5, 5] **
[5, 5, 0, 1, "0", "0", "0", 1, 0, 5, 5, 5] ** 
[5, 5, 0, 1, 1, 1, 1, 1, 0, 5, 5, 5]
[5, 5, 0, 1, 1, 1, 1, 1, 0, 5, 5, 5]
[5, 5, 0, 1, 1, 1, 1, 1, 0, 5, 5, 5]
[5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5]
[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
>> 반례

생각해봐, **가 해결이 안됨.

[해결7] >>> b2636_bfs.py파일 !! 
무조건 BFS야.. 하...
그냥 BFS로 돌리고, 1나오면 탐색 그만 하는 방향


'''